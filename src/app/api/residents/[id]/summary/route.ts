import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireOperatorOrAdmin } from '@/lib/rbac';
import PDFDocument from 'pdfkit';

export const dynamic = 'force-dynamic';

// Assumptions:
// - Generates an operational summary PDF for a resident.
// - RBAC: Admins can access any resident; Operators only within their homes.
// - PHI: Minimal necessary disclosure; no clinical data beyond high-level counts.
// - Auditing: Download events should be captured by upstream logging; not persisted here.

async function canAccess(sessionEmail: string | null | undefined, residentId: string) {
  if (!sessionEmail) return false;
  const user = await prisma.user.findUnique({ where: { email: sessionEmail }, select: { id: true, role: true } });
  if (!user) return false;
  if (user.role === 'ADMIN') return true;
  if (user.role === 'OPERATOR') {
    const op = await prisma.operator.findUnique({ where: { userId: user.id }, select: { id: true } });
    if (!op) return false;
    const res = await prisma.resident.findUnique({ where: { id: residentId }, select: { home: { select: { operatorId: true } } } });
    if (!res) return false;
    return res.home?.operatorId === op.id;
  }
  return false;
}

export async function GET(_req: NextRequest, { params }: { params: { id: string } }) {
  try {
    const { session, error } = await requireOperatorOrAdmin();
    if (error) return error;
    if (!(await canAccess(session!.user!.email, params.id))) return NextResponse.json({ error: 'Forbidden' }, { status: 403 });

    const resident = await prisma.resident.findUnique({
      where: { id: params.id },
      select: {
        id: true, firstName: true, lastName: true, status: true, gender: true, dateOfBirth: true,
        home: { select: { name: true } },
      },
    });
    if (!resident) return NextResponse.json({ error: 'Not found' }, { status: 404 });

    const [docCount, assessCount, incidentCount] = await Promise.all([
      prisma.document.count({ where: { residentId: params.id } }),
      prisma.assessmentResult.count({ where: { residentId: params.id } }),
      prisma.residentIncident.count({ where: { residentId: params.id } }),
    ]);

    // Build PDF into a Buffer (small doc)
    const doc = new PDFDocument({ size: 'A4', margin: 50 });
    const chunks: Buffer[] = [];
    doc.on('data', (c: Buffer | Uint8Array) =>
      chunks.push(Buffer.isBuffer(c) ? c : Buffer.from(c))
    );
    const done = new Promise<Buffer>((resolve) => doc.on('end', () => resolve(Buffer.concat(chunks))));

    // Header
    const centerOptions = { align: 'center' as const };
    doc.fontSize(18).text('CareLinkAI Resident Summary', centerOptions);
    doc.moveDown();
    doc.fontSize(12);
    doc.text(`Resident: ${resident.firstName} ${resident.lastName}`);
    doc.text(`Status: ${resident.status}`);
    doc.text(`Home: ${resident.home?.name ?? '—'}`);
    const dob = resident.dateOfBirth ? new Date(resident.dateOfBirth).toISOString().slice(0, 10) : '—';
    doc.text(`DOB: ${dob}`);
    doc.text(`Gender: ${resident.gender}`);
    doc.moveDown();

    // Metrics
    doc.fontSize(14).text('Summary Metrics');
    doc.moveDown(0.5);
    doc.fontSize(12);
    doc.text(`Documents: ${docCount}`);
    doc.text(`Assessments: ${assessCount}`);
    doc.text(`Incidents: ${incidentCount}`);
    doc.moveDown();

    const rightOptions = { align: 'right' as const };
    doc.fontSize(10).fillColor('gray').text('Generated by CareLinkAI', rightOptions);
    doc.end();
    const buffer = await done;

    const filename = `resident-${resident.id}-summary.pdf`;
    return new NextResponse(new Uint8Array(buffer), {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `inline; filename="${filename}"`,
        'Cache-Control': 'private, no-store',
      },
    });
  } catch (e) {
    console.error('Resident summary PDF error', e);
    return NextResponse.json({ error: 'Server error' }, { status: 500 });
  }
}
